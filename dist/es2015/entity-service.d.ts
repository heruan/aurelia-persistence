import { HttpResponseMessage } from "aurelia-http-client";
import { EventAggregator } from "aurelia-event-aggregator";
import { HttpClient } from "aurelia-http-client";
import { EntityManager } from "./entity-manager";
import { Query } from "./query";
import { Sorting } from "./sorting";
import { JsonDecoder } from "aurelia-json";
import { CancelablePromise } from "aurelia-utils";
export declare class EntityService {
    static COUNT_TOTAL_HEADER: string;
    static COUNT_FILTER_HEADER: string;
    static FILTER_HEADER: string;
    static LIMIT_HEADER: string;
    static SKIP_HEADER: string;
    static SORT_HEADER: string;
    static PROPERTY_FILTER_HEADER: string;
    private eventAggregator;
    private jsonDecoder;
    private httpClient;
    private entityManager;
    private jsonSchema;
    private links;
    private requestMap;
    constructor(entityManager: EntityManager, eventAggregator: EventAggregator, jsonDecoder: JsonDecoder, httpClient: HttpClient, jsonSchema: Map<string, any>, links: Map<string, string>);
    getEntityManager(): EntityManager;
    getSchema(): Map<string, any>;
    link(relation: string, params?: Object): string;
    searchMessage(requestId: string, path: string, filter?: Query, limit?: number, skip?: number, sort?: Sorting, properties?: string[], progressCallback?: Function): CancelablePromise<HttpResponseMessage>;
    cancel(requestId: string): void;
    setRequestId(requestId: string, request: any): void;
    count(requestId: string, filter?: Query, relation?: string, params?: Object, progressCallback?: Function): Promise<number>;
    findAll(requestId: string, filter?: Query, limit?: number, skip?: number, sort?: Sorting, properties?: string[], relation?: string, params?: Object, progressCallback?: Function): Promise<any[]>;
    findOne(requestId: string, filter?: Query, skip?: number, sort?: Sorting, properties?: string[], relation?: string, params?: Object, progressCallback?: Function): Promise<any>;
    retrieve(entity: any, relation?: string, params?: Object, properties?: string[], progressCallback?: Function): Promise<any>;
    persist(entity: any, relation?: string, params?: Object, progressCallback?: Function): Promise<any>;
    update(entity: any, relation?: string, params?: Object, progressCallback?: Function): Promise<any>;
    patch(entity: any, relation?: string, params?: Object, properties?: string[], progressCallback?: Function): Promise<any>;
    delete(entity: any, relation?: string, params?: Object, progressCallback?: Function): Promise<HttpResponseMessage>;
    stringify(entity: any): string;
    private requestBuilder(relation, entity, params?);
    private inferContentType(entity);
}
